= Plugin Management APIs

[[overview]]
== Overview

Started with Kill Bill 0.16.0, it is now possible to go through all the lifecycle (`install`, `start`, `stop`, `uninstall` and `list status`) of a plugin using apis.
The apis have been designed to work on a killbill deployment that consists of several instances.

The feature relies on the following pieces:

* A running version of a (or several) killbill server(s)
* A running https://github.com/killbill/killbill-kpm-plugin[KPM plugin] on each killbill instance.

Installing the KPM plugin will first need to happen using https://github.com/killbill/killbill-cloud/tree/master/kpm[KPM] itself.


== APIs

Each of the API refers to a plugin using a `pluginKey`. A `pluginKey` can be one of the following:

* An entry in the official Kill Bill https://github.com/killbill/killbill-cloud/blob/master/kpm/lib/kpm/plugins_directory.yml[plugin reporsitory],
* A user provided key that will be used to identify this plugin when using the APIs. The user provided key must be unique and must contain a namespace (e.g MY_NAMESPACE:myKey). During the installation phase, and when using a user provided key, one must also specify additonal properties to specify the location of that plugin.
  
The following APIs are supported:

* INSTALL_PLUGIN: Install a plugin. The following properties are supported:
** `pluginKey`: required
** `pluginType`: required for user provided key  (can be `ruby` or `java`)
** `pluginVersion`: optional (will default to LATEST version)
** `pluginArtifactId`: required for user provided key  (the maven `artifactId`)
** `pluginGroupId`: required for user provided key  (the maven `groupId`)
** `pluginPackaging`: optional (the maven `packaging` that will default to `jar` for `java` plugin and `tar.gz` for `ruby` plugins)
** `pluginClassifier`: optional (the maven `classifier` that will default to null)
* START_PLUGIN: Start a plugin. The following properties are supported:
** `pluginKey`: required
** `pluginVersion`: optional (will default to LATEST version)
* RESTART_PLUGIN:  Restart a plugin. All classes will be unloaded and new classes/ruby files will be loeaded and started. The following properties are supported:
** `pluginKey`: required
** `pluginVersion`: optional (will default to LATEST version)
* STOP_PLUGIN: Stop a plugin. All classes will be unloaded. The following properties are supported:
** `pluginKey`: required
** `pluginVersion`: optional (will default to LATEST version)
* UNINSTALL_PLUGIN: The command will disable the plugin so it will not be listed as the installed plugin, but the code will be kept on the filesystem (to optimize cases where one would want to re-install the same version of the plugin):
** `pluginKey`: required
** `pluginVersion`: optional (will default to LATEST version)


=== Installation

The installation of a plugin occurs through the KPM plugin (which itself relies on KPM) and  consists of the following sequence:

* Download the binaries and installing them on the filesystem at the right place
* Set that latest downloaded version as being the default one to start (`isSelectedForStart`)
* Notify killbill core to update its view of the existing plugins

Example of installing a `paypal plugin` with a specified version of `4.0.0`:
[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":"true","nodeCommandType":"INSTALL_PLUGIN","nodeCommandProperties":[{"key":"pluginKey", "value":"paypal"}, {"key":"pluginVersion","value":"4.0.0"} ]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

Example of installing a `payment test plugin` (one must include all the maven coordinates to specify where this plugin should be installed from):
[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":"true","nodeCommandType":"INSTALL_PLUGIN","nodeCommandProperties":[{"key":"pluginKey", "value":"killbill:payment-test"},{"key":"pluginArtifactId", "value": "payment-test-plugin"},{"key":"pluginGroupId", "value": "org.kill-bill.billing.plugin.ruby"}, {"key": "pluginType", "value": "ruby"} ]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

=== Starting a plugin

Starting a plugin occurs purely through killbill (independent of the KPM plugin) and  consists of the following sequence:

* Load the classes through the OSGI mechanism
* Start the plugin
* Update its view of the existing plugins

Example of starting the default installed version for the `paypal plugin`:

[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":true,"nodeCommandType":"START_PLUGIN","nodeCommandProperties":[{"key":"pluginKey","value":"paypal"}]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

=== Stopping a plugin

Stopping a plugin occurs purely through killbill (independent of the KPM plugin) and  consists of the following sequence:

* Stop the plugin
* Unload the classes through the OSGI mechanism
* Update its view of the existing plugins

Example of stopping the running version of the  `paypal plugin`:

[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":true,"nodeCommandType":"STOP_PLUGIN","nodeCommandProperties":[{"key":"pluginKey","value":"paypal"}]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

=== Restarting a plugin

Restarting a plugin consists of first stopping the plugin and then restarted the plugin (therefore unloading previous classes/code and reloading new one with a potentially different version).

Example of restarting the running version of the  `paypal plugin`:

[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":true,"nodeCommandType":"RESTART_PLUGIN","nodeCommandProperties":[{"key":"pluginKey","value":"paypal"}]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

=== Uninstallation

Uninstalling a plugin consists in marking that plugin as being `disabled`. The code remains on the filesystem but killbill will ignore it.

Example of uninstalling the  `paypal plugin`:

[source,bash]
----
curl -v \
-u admin:password \
-H "X-Killbill-ApiKey: bob" \
-H 'X-Killbill-ApiSecret: lazar' \
-H "Content-Type: application/json" \
-H 'X-Killbill-CreatedBy: stephane' \
-X POST \
--data-binary '{"systemCommandType":"true","nodeCommandType":"UNINSTALL_PLUGIN","nodeCommandProperties":[{"key":"pluginKey", "value":"paypal"} ]}' \
"http://127.0.0.1:8080/1.0/kb/nodesInfo"
----

=== Listing all the plugins

There is an api to retrieve the current view for each killbill node. That API provides details about the running versions of a killbill node along with all the plugin detail information (the json can be quote long so for better readibility one can pipe the output to `python -m json.tool` to format it nicely:

[source,bash]
----
curl -u'admin:password' -v -H "X-Killbill-ApiKey: bob" -H 'X-Killbill-ApiSecret:lazar' http://127.0.0.1:8080/1.0/kb/nodesInfo | python -m json.tool
----

That would provide the following output:

There is an array of entries, one for each running killbill instance. Each of these entresi will contain the following:

* nodeName: By default this is the `hostname` of the node running, but this can be configured.
* bootTime: Time at which that node started
* kbVersion: Version for https://github.com/killbill/killbill[killbill]
* apiVersion: Version for https://github.com/killbill/killbill-api[killbill-api]
* pluginApiVersion: Version https://github.com/killbill/killbill-plugin-api[for killbill-plugin-api]
* platformVersion: Version for https://github.com/killbill/killbill-platform[killbill-platform]
* commonVersion: Version for https://github.com/killbill/killbill-commons[killbill-commons]
* pluginsInfo: One entry for each plugin:
** pluginKey: The plugin key
** pluginName: The name of the plugin as seen on the filesystem. It is used internally by killbill to idenitify a plugin, but that name is only available after the plugin has been installed and could be changed from one installation to the next.
** bundleSymbolicName: The OSGI symbolic name (from the `MANIFEST.mf`)
** isSelectedForStart: If this is the default version to be started for that plugin
** services: The plugin apis that this plugin implements

Example of an output:

[source,bash]
----
[
    {
        "apiVersion": "0.32",
        "bootTime": "2015-12-18T19:44:23.000Z",
        "commonVersion": "0.12",
        "kbVersion": "0.15.11-SNAPSHOT",
        "lastUpdatedDate": "2015-12-18T19:44:23.000Z",
        "nodeName": "GM17573-8080",
        "platformVersion": "0.19",
        "pluginApiVersion": "0.18",
        "pluginsInfo": [
            {
                "bundleSymbolicName": "org.kill-bill.billing.plugin.java.analytics-plugin",
                "isSelectedForStart": true,
                "pluginKey": "analytics",
                "pluginName": "analytics-plugin",
                "services": [
                    {
                        "registrationName": "killbill-analytics",
                        "serviceTypeName": "javax.servlet.Servlet"
                    }
                ],
                "state": "RUNNING",
                "version": "2.0.2"
            },
.....
----

== Internals

=== Multi-node Implementation

Each killbill node writes the details about its versions, plugins info right after it has started. When there is any change in the system, each node is notified through a broadcast mechanism and it updates its entry guaranting that at any time the info matches the current state.

The broadcast mechanism is based on a simple mechanism where each node polls periodically a database table shwoing the command to execute. When the system (each node) picks up a new entry, it then sends a special bus event so that different killbill components and plugin can react to the event and carry out the action.

=== Installation/Uninstallation 

Installing/uninstalling a plugin using the api is slightly different than installing/uninstalling the plugin using KPM directly. The main reason has to do with the `pluginKey`:

* When installing/uninstalling a plugin using the api, one must provide a `pluginKey`. KPM will update a configuration file under `ROOT/plugins/plugin_identifiers.json` to keep the mapping between that `pluginKey` and the `pluginName` which is the location on the filesystem where this plugin is being deployed (`ROOT/plugins/{java|ruby}/pluginName/pluginVersion`)
* When installing/uninstalling a plugin directly through KPM, one does not need to provide a `pluginKey` and the mapping is not created.

=== KPM Plugin

Plugin installation and uninstallation are handled by the KPM plugin, whose role is to simply listen for bus events to then delegate the installation/uninstallation the the KPM gem and then notify killbill about the result.

For all other operations (start/stop/restart), the KPM plugin is not involved.




