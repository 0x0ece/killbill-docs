Kill Bill has a payment subsystem which offers several APIs:

* payment and refund APIs for recurring billing
* *direct* payment APIs for one-off charges

The former set of APIs is used by the core billing engine to charge for subscriptions, and by Kaui (the Kill Bill Admin UI) to handle refunds, chargebacks, adjustments, etc. for invoices and payments associated with such subscriptions.

The latter set can be used by your application to trigger payments (auth, capture, credit, refund, etc.) by your e-commerce application (e.g. shopping cart). It offers also helpers to create payment forms and redirect URLs in case of hosted payment pages.

Kill Bill, being a generic platform to build billing and payment infrastructures, is agnostic of payment gateways. Instead, it provides a framework to register payment plugins, which in turn implement gateway specific APIs. Those payment plugins must be OSGI compliant plugins. They can be written either in:

* java; in which case they are just a standard OSGI java jar which must register a service implementing the https://github.com/killbill/killbill-plugin-api/blob/master/payment/src/main/java/org/killbill/billing/payment/plugin/api/PaymentPluginApi.java[PaymentPluginApi]
* ruby; in which case they must use the https://github.com/killbill/killbill-plugin-framework-ruby[killbill gem] which provides a jruby bridge between java and ruby. Those plugins must inherit the https://github.com/killbill/killbill-plugin-framework-ruby/blob/master/lib/killbill/payment.rb[Payment class] to provide the specific plugin code functionality

The main reason to provide a way to write ruby payment plugins is to be able to reuse the http://activemerchant.org/[Active Merchant] gem. We even have a https://github.com/killbill/killbill-plugin-framework-ruby/[generator] to help you generate a payment plugin from an Active Merchant implementation.

Check the wiki page https://github.com/killbill/killbill/wiki/Payment-plugins[Payment Plugins] for a community-supported list of already written payment plugins.

The Kill Bill payment code will detect all the payment plugins registered in the system and decide which plugin to use when a charge, refund, ... operation needs to happen. The dispatching is based on the payment methods associated with each account. By default, the model is to attach a default payment method to each account and that payment method will have a link that points to a specific plugin to use. For instance one account could have a Paypal payment method that would point to the paypal plugin. In addition to that direct payment apis also allow to override the payment method that should be used for each payment.

By default Kill Bill does not come configured with any payment plugins per se except for the built-in __EXTERNAL_PAYMENT__, which is used to track payments which occurred outside of Kill Bill. A typical example would be for when a customer pays by check and we want to make sure the invoice balance is set to 0 after receiving the check. A user, represented in Kill Bill as an Account can add as many payment methods as required, and each of those will identify a specific plugin that Kill Bill will use when making payments.

=== Payment states

==== Hosted page

For hosted pages, the entry point for any payment is the *buildFormDescriptor* API. This will create the payment id and set the status *SETUP* for the payment, before calling the plugin. Since *buildFormDescriptor* should not trigger any payment on the gateway, the payment at this stage is merely set up when the call returns.

Kill Bill will then start polling the plugin via the *getPaymentInfo* API, to check for payment state changes:

* if the plugin throws an error, the payment moves to the *PLUGIN_FAILURE* state
* if the plugin returns *UNDEFINED*, the payment stays in *SETUP*
* if the plugin returns *PENDING*, the payment moves to the *PENDING* state
* if the plugin returns *PROCESSED*, the payment moves to the *SUCCESS* terminal state, and the polling stops
* if the plugin returns *ERROR*, the payment moves to the *PAYMENT_FAILURE_ABORTED* terminal state, and the polling stops

Eventually, after a configurable timeout period, Kill Bill forces the payment to move to ones of these following terminal states: *SETUP_ABORTED*, *PAYMENT_FAILURE_ABORTED* or *PLUGIN_FAILURE_ABORTED*.

image::payment_states.svg[Kill Bill payment states, align="center"]

Alternatively, the plugin can also notify Kill Bill of the payment state change via the *notifyPendingPaymentOfStateChanged* API, to move the payment to either the *SUCCESS* or *PAYMENT_FAILURE_ABORTED* terminal state.

==== Gateway integration

For gateway integrations, the entry point for any payment is either the *createAuthorization* or *createPurchase* API. Both calls create a direct payment id before calling the plugin.

All of the payment APIs (*createAuthorization*, *createPurchase*, *createCapture*, *createCredit* and *creditVoid*) will attach transaction records to that original direct payment: for example, a direct payment can have an authorization and two capture transactions associated to it. Each transaction has its own state upon returning from the plugin:

* if the plugin throws an error, the payment moves to the *PLUGIN_FAILURE_ABORTED* terminal state
* if the plugin returns *UNDEFINED* the payment moves to the *PLUGIN_FAILURE_ABORTED* terminal state
* if the plugin returns *PROCESSED*, the payment moves to the *SUCCESS* terminal state
* if the plugin returns *ERROR*, the payment moves to the *PAYMENT_FAILURE_ABORTED* terminal state
* if the plugin returns *PENDING*, the payment moves to the *PENDING* state. This is used for multi-step calls (e.g. 3D Secure authorization)

Note that contrary to the hosted page scenario, transactions always end up in a terminal state right away. There is no polling needed because the gateway will return the payment status synchronously (there is not asynchronous notification). The only exception to this is when the payment ends up in the *PENDING* state. Plugins set this status when additional steps are required to acknowledge the payment, for example in case of 3D Secure or Bitcoin (while waiting on miners to integrate the transaction deep enough in the blockchain).

image::pending_payment_state.svg[Kill Bill pending payment state, align="center"]
