= Kill Bill Migration Guide

== Overview

This guide is intended to provide some guidelines for running migrations from an **existing billing system** to **Kill Bill**.
It is by no mean an exact recipe book to follow, but it provides some recommendations on how to do things (based on previous experiences) and highlight some specific areas of concern.

The assumption is there is already an internal or third party billing system in place:

* It receives some live traffic, and migration should not cause any downtime
* It contains existing state (subscriptions, invoices, ...) that need to be migrated without impacting customers
* It provides a UI for customer service (CS) use to handle customer tickets
* It provides state/data that is used by accounting/financial departments
* One or several systems in the company are interracting with that billing system through API calls or by ETLing data

The end goal of the migration is to make sure that we can unplug completely the old billing system and yet provide the same level of service (or better) for the customers and the various departments in the organization.

This is a fairly ambitious goal, which may require some tradeoffs and a gradual shutdwon of the old system.

== Strategy

Like most complicated projects, it make sense to cut the projects in separate stages and also look for any amount of simplifications. 

=== What Needs to be Migrated?

One must first decide on the data that must be migrated, so let's start by the minimum amount of data that needs to be migrated:

* **Account data**: All the customer info such as name, email, phone, address, ... pretty much everything that would fit on the Kill Bill `Account` table. If additional data needs to be kept one could use custom fields to add key-value paremeters attached to the account data.
* **Active Subscriptions**: In order for users to still be billed and receive service, those need to be migrated and in a way to allow to swicth from one system to the next with no (minimum) impact/visibility. 

Other state such as non active subscriptions, past invoices, and payments *don't need* to be migrated to have the system function correctly, but **that data may still need to be available in some fashion**. By not migrating that data into Kill Bill, this simplifies the problem:

* **Non active subscriptions**: Migrating those means migrating more data; also it is often the case that the older the data the less 'clean' it is and the harder it is to migrate (associated `Plan` may not be active anymore, previous bugs from existing billing systems mauy create difficult data to migrate, ...). Also, while this is feasible, this does not add too much value unless one wants to also migrate past invoices
* **Past Invoices**: Those are difficult to migrate as such, because they can't simply be replayed by Kill Bill (if we were to migrate all subscriptions and let Kill Bill catch up with invoices the result would be a set of invoices not exactly identical to the original system (pro-ration logic would be different, catalog may have been configured slightly differently on old system and in Kill Bill,...) and so those would not be useful as they could not provide a real replacement for past invoices. Another strategy would be to insert them manually in the invoice table to make sure they exactly match, but then invoices and subscriptions would not correspond exactly and system would try to correct the state. Also such a strategy would require inserting data directly or providing custom endpoints to touch these tables, both of which are risky and error prone initiatives.
* **Past Payments**: Those are exactly similar to what we described for invoices. They need to match exactly past invoices and the same set of challenge exists here.

So, let's look at the use cases for this data, and see how we suggest one can simplify the problem:

* **Customer Use Case**: Customers may still need to access their old invoices and payments. Assuming this data is static one could keep those (past invoices and payments) outside of the pure Kill Bill tables (could be same database with additional tables, or entirely different database) and provide new apis they fetch existing invoices and payments by merging old data with the new one from Kill Bill. Now, keeping that data completely static is a challenge because customers may still require some invoice adjustements, payment refunds associated with this old data... A good strategy here is to keep the old system alive for a while after the migration has been completed and serve those invoices/payments from the old system, allowing to still make the changes from the old system. After a while (maybe a few months) there will be very few such adjustments to make on those old invoices/payments and that data can be fetched and served from a static source. Isolated cases where customers still require some changes associated with these old invoices/payments cannot be made anymore but customer could still be satisfied by generating invoice or payment credit. Finally Accounting/Finance departments would barely impacted because the number of such requests becomes very few. So finally the old system can be fully unplugged.

* **Finance/Acounting departement**: They will still require old invoice and payment data to run reports but it does not necessarily need to be part of Kill Bill. A good alternative is to provide some kind of a view that will merge both the old data (from old billing system) and the new data coming from Kill Bill. Again here the old data could be ETLed from old system as long as it is alive and then data could be materialized after it has been extinct.

=== How Does Migration Work?

==== Migration Cutover Dates

The first thing to discuss is the **cutOverDate**, that is the date at which Kill Bill starts handling requests. In fact, we made the assumption that the migration would happen on a live system (with no downtime), and that has two consequences:

* The first consequence is that there needs to be a point in time where **new accounts** will be created in Bill Bill. While this is not a migration data issue (because those new accounts would never see the old system, so there is no data to migrate), we still need to define when is that **newAccountCutOverDate**
* The second consequence is that because we will make that migration work with no downtime, it does not need to happen all at once. In fact we propose to migrate the existing accounts on a per account basis. That way each account is migrated independently of the other (and occasional failures can be investigated and retried). So we will have one **cutOverDate** per account.

So assuming we have N existing accounts to migrate, we end up one **newAccountCutOverDate** and N **cutOverDate**. We need to first move new accounts to Kill Bill before migrating any of the  existing accounts because:

** Only when old billing system stops accepting new accounts, can we evaluate how many existing accounts there are (N becomes fixed at this point),
** This allows to verify that Kill Bill works as expected before we start migrating data.

==== Migration Framework

The migration code consists in several pieces:

** Ability to make api calls to old billing system (may already exist in some form)
** Ability to make api calls to Kill Bill (mandatory to handle new accounts regardless of migration data)
** Ability to set/get  **newAccountCutOverDate** and N **cutOverDate**
** Ability to route traffic to one (or both system)

The choice of where those pieces are implemented really depends on the current architecture of the system. For instance if the code interracting with the existing billing system is well isolated, those new functions could take place at this level (client side). Conversely, if there are many components already interracting with the existing billing system, it might make sense to provide a new proxy server that encapsulate all that logic and have thpse components go through that proxy (and from an implementation point of view that proxy server could live in the same webapp as Kill Bill and access some new tables in the same database). The migration logic shown in the figure below is represented in a separate box but again it could live at different place.










== Stages

=== Stage 1: Setting up Kill Bill

=== Stage 2: Behavioral Analysis

=== Stage 3: Behavioral Analysis

=== Stage 4: Running the Migration




